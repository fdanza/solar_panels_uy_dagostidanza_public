---
title:    "Capacity and Battery Exercises"
subtitle: "Robustness Checks"
authors:  "Natalia D'Agosti & Facundo Danza" 
---

# Load the packages

First, we load the necessary pacakges:
```{r}
rm(list=ls())
gc()
```

Second, we load the packages
```{r}
# install.packages("pacman")
pacman::p_load(tidyverse, lubridate, readxl, 
               sandwich, arm, fixest, gapminder, car, 
               gurobi, Matrix, boot)
#library(margins)
```

Third, we set the plotting theme:
```{r}
theme_set(theme_bw())
```

Then, we load the directories:
```{r}
dir        <- list()
dir$root   <- dirname(getwd())
dir$data   <- paste0(dirname(getwd()), "/data/")
dir$fig    <- paste0(dirname(getwd()), "/figures/")
dir$tab    <- paste0(dirname(getwd()), "/tables/")
```


# Clean the databases

## First database

Upload the data
*First database: Copia de informacion - Facundo Danza*
```{r}
MG_data <- 
  read_excel(paste0(dir$data,"data/Copia de información-Facundo Danza.xlsx"), 
             sheet=1 ,range="A2:BA1293")
```

Arrange the name of the variables:
```{r}
MG_data <- MG_data %>% rename("ID" = "Número", 
                            "MG_install_date" ="Fecha puesta en servicio de la IMG",
                            "dto" ="Departamento",
                            "power_hired_W" = "Potencia contratada (W)",
                            "power_nominal_W"="Potencia nominal de la IMG (W)",
                            "contract"= "Persona física / persona jurídica",
                            "iny_2020_10"="44105...7",
                            "iny_2020_11"="44136...8",
                            "iny_2020_12"="44166...9",
                            "iny_2021_01"="44197...10",
                            "iny_2021_02"="44228...11",
                            "iny_2021_03"="44256...12",
                            "iny_2021_04"="44287...13",
                            "iny_2021_05"="44317...14",
                            "iny_2021_06"="44348...15",
                            "iny_2021_07"="44378...16",
                            "iny_2021_08"="44409...17",
                            "iny_2021_09"="44440...18",
                            "iny_2021_10"="44470...19",
                            "iny_2021_11"="44501...20",
                            "iny_2021_12"="44531...21",
                            "iny_2022_01"="44562...22",
                            "iny_2022_02"="44593...23",
                            "iny_2022_03"="44621...24",
                            "iny_2022_04"="44652...25",
                            "iny_2022_05"="44682...26",
                            "iny_2022_06"="44713...27",
                            "iny_2022_07"="44743...28",
                            "iny_2022_08"="44774...29",
                            
                            
                            "ext_2020_10"="44105...31",
                            "ext_2020_11"="44136...32",
                            "ext_2020_12"="44166...33",
                            "ext_2021_01"="44197...34",
                            "ext_2021_02"="44228...35",
                            "ext_2021_03"="44256...36",
                            "ext_2021_04"="44287...37",
                            "ext_2021_05"="44317...38",
                            "ext_2021_06"="44348...39",
                            "ext_2021_07"="44378...40",
                            "ext_2021_08"="44409...41",
                            "ext_2021_09"="44440...42",
                            "ext_2021_10"="44470...43",
                            "ext_2021_11"="44501...44",
                            "ext_2021_12"="44531...45",
                            "ext_2022_01"="44562...46",
                            "ext_2022_02"="44593...47",
                            "ext_2022_03"="44621...48",
                            "ext_2022_04"="44652...49",
                            "ext_2022_05"="44682...50",
                            "ext_2022_06"="44713...51",
                            "ext_2022_07"="44743...52",
                            "ext_2022_08"="44774...53")
```

Eliminate a column that has no data
```{r}
MG_data <- MG_data %>% 
  dplyr::select(-c(30))
```

```{r}
MG_data = 
  MG_data %>% 
  mutate(inst_date = 
           as.Date(MG_install_date))

MG_data$inst_month_yr <- format(
  as.Date(MG_data$inst_date), "%Y-%m")
```

```{r}
# we want to study capacity for the years in which we have better data
MG_data = 
  MG_data %>% 
  mutate(year = 
           year(MG_install_date), 
         month = 
           month(MG_install_date), 
         type = 
           ifelse(contract == "jurídica",
              "NEGOCIO", 
              "HOGAR"))
```

## Evolution of capacity

```{r}
x_label = "2010-01"

for (i in seq(2012,2024,2)) {
  x_label = c(x_label, paste0(i,"-01"))
}

plot_new_micro2 <- MG_data %>%
  filter(type == "NEGOCIO") %>%
  group_by(inst_month_yr) %>% 
  summarise(avg_capacity = 
              mean(power_nominal_W, na.rm = T)) %>%
  ggplot(aes(x=inst_month_yr, 
             y=avg_capacity), size=2) +
  geom_point(size=2, 
           color="darkgray") +
  theme(text = element_text(size = 15)) + 
  labs(y = "Solar Panel Capacity (W)",
       x = "Date") + 
  scale_x_discrete(breaks = x_label) +
  theme(legend.key.size = unit(1, 'cm'))

plot_new_micro2
```

```{r}
ggsave(paste0(dir$fig,"plot_micro_capacity.png"), 
              width = 7, height = 4.5)
```

### Regression analysis

```{r}
setFixest_dict(c(`I(year-2011)` = "Year",
                 power_nominal_W   = "Solar Panel Capacity (W)",
                "ext-ener_iny"  = "Net Effect (kWh)",
                 ATT  = "Solar Panel Installation", 
                 ID_34 = "ID",
                 dto   = "State",
                 month = "Month", 
                 year = "Year", 
                month_plot  = 
                   "Month of Treatment"), 
               reset = TRUE)
```


```{r}
reg_capacity_round <- feols(
  power_nominal_W ~ I(year-2011),
  cluster = "year",
  data = MG_data %>%
    filter(type == "NEGOCIO" & 
             !is.na(year))
)

reg_capacity_all =
  list(reg_capacity_round)

for (fx in c("month")) {
  
  formula_round = 
    paste0("power_nominal_W ~ I(year-2011) | ", fx)
  
  reg_capacity_round <- 
    feols(as.formula(formula_round),
          cluster = "year",
          data = MG_data %>%
            filter(type == "NEGOCIO" & 
                     !is.na(year)))
          
  reg_capacity_all =
    c(reg_capacity_all, list(reg_capacity_round))
}
```


```{r}
etable(reg_capacity_all,
         file = paste0(dir$tab,
                       "capacity_reg.txt"),
       replace = TRUE)

etable(reg_capacity_all)
```
We clean up the table a bit more, as we add this information in the notes of the table:
```{r}
# Load the table into R as text
etable_path <- 
  paste0(dir$tab,
         "capacity_reg.txt")

etable_text <- 
  readLines(etable_path)

# Remove the 3rd and 4th to last lines
etable_text_cleaned <- 
  etable_text[-c((length(etable_text) - 5), 
                 (length(etable_text) - 4))]

# Write the cleaned table back to the same file or a new file
writeLines(etable_text_cleaned, 
           etable_path)
```

# Back-of-the-Envelope Calculations

In this code, we do the CO2 emissions reduction calculations and the minimization problem on emissions. We use Gurobi for the latter.  

## Clean Data

First, we arrange the hydro, thermal, biomass, wind, solar, demand, imports and exports data
```{r}
final_energy <- 
  read.csv(paste0(dir$data,"Gurobi/final_all.csv")) # this is till the year 2020

final_energy <- final_energy %>% 
  dplyr::select("year", "month", "day", "hour", "wind", "solar", "biomass", "thermal", "hydro", "demand", "total_exports", "total_imports") #eliminate the congestion variable that do not play a role
```

Then, we load the the year 2021 and 2022. This was done is the code `2.0.1_clean_electricity_gurobi.Rmd`
```{r}
load(paste0(dir$data, 
            "Gurobi/ADME_electricity_production/final_2021.RData"))

final_2021 <- final_2021 %>% 
  mutate (total_exports=-total_exports)

load(paste0(dir$data, 
            "Gurobi/ADME_electricity_production/final_2022.RData"))

final_2022 <- final_2022 %>% 
  mutate (total_exports=-total_exports)

final_production <- 
  rbind(final_energy, final_2021, final_2022) 

rm(final_energy, final_2021, final_2022) #Drop the dataframes that we don't need anymore
```

We add the electricity injected data of electricity into the grid.

We have the total electricity production of the month for each hour. The R data we use is  `data/Gurobi/final_elec_inyected_normal.RData`, which comes from the R-code `2.0.2_arrange_injection_data_for_Gurobi.Rmd`

*Caution: the number is the same for every hour within a month, and is the total production, not the hourly production*
```{r}
load(paste0(dir$data,
            "Gurobi/final_elec_inyected_normal.RData"))
```

## CO2 Factor

In this section, we calculate the CO2 factor per hour. 

First, we add the CO2 emissions data. This was partially done in R-code `2.0.3_arrange_co2_data_for_Gurobi.Rmd`

*Caution: CO2 emissions is the total per month, and is the same number for all the hours of all the days*
```{r}
load(paste0(dir$data,
            "/Gurobi/final_co2_G.RData"))

final_co2_G <- 
  final_co2_G %>% 
  dplyr::select(year, month, day, hour, everything()) #change the order of columns
```


```{r}
#merge it with the other variable:
final_co2_G <- merge(final_co2_G, final_production, 
                     by=c("year", "month", "day", "hour"))

rm(final_production)
```

The total number of days and the total production of thermal in a month. Then, we calculate the amount of CO2 emissions per unit of thermal production. Lastly, we adjust the hourly CO2 emissions factor to reflect the total amount of thermal production was needed that day. For more details, please refer to the appendix of the paper.
```{r}
final_co2_G <- final_co2_G %>% 
  group_by(year, month) %>% 
  mutate(max_day = max(day), 
         total_thermal_month = 
           sum(thermal)) %>% 
  ungroup() %>% 
  mutate(co2_per_unit = 
           desc_co2/total_thermal_month) %>%
  group_by(year, month, day) %>% 
  mutate(total_thermal_day = 
           sum(thermal), 
         total_thermal_day_square = 
           sum(thermal^2)) %>%
  ungroup() %>% 
  mutate(ponderator = 
           thermal/total_thermal_day,
         scale_pond = 
           total_thermal_day^2/total_thermal_day_square,
         perc_thermal = 
           ifelse(total_thermal_day == 0, 
                  0,
                  scale_pond*ponderator*co2_per_unit))
```

We check that the hourly sum of the CO2 emissions reflects the CO2 emissions of the month below:
```{r}
# final_co2_G_check = 
#   final_co2_G %>%
#   filter(month == 11 & year == 2018) %>% 
#   summarise(co2_total_factor = 
#               sum(perc_thermal*thermal, na.rm = T), 
#             co2_total     = mean(desc_co2))
```


We finally add the electricity injected into the grid to hour main database:
```{r}
final_gurobi <- 
  merge(final_elec_inyected, final_co2_G, 
        by=c("year", "month", "day", "hour")) 
#Merge the electricity injected to the grid with the production of sources

extraction_gurobi = 
  read_csv(paste0(dir$data,
                  "constructed_data/n_of_mg.csv" ), 
           col_types = cols())

final_gurobi = 
  final_gurobi %>%
  left_join(extraction_gurobi, by = c("month", "year"))
```

We calculate the daily injection and extraction-reduction implied from our estimation (our data is in kWh while the thermal is in GWh - we adjust that)
```{r}
final_gurobi = 
  final_gurobi %>%
  mutate(ener_ext  = treat_effect_ext*count_mg, 
         ener_iny_a = treat_effect_inj*count_mg) %>%
  mutate(across(starts_with("ener_"), 
                ~ .x/1000))
```


```{r}
rm(final_co2_G, 
   final_elec_inyected, 
   extraction_gurobi) # eliminate the databases we do not need
```


## CO2 emissions - Back-of-the-Envolpe Calculation

We need to define the distribution within a hour of solar production for the microgenerated solar production. 

We assume that the daily solar is proportionally distributed as the total solar production is. That is, for example, if 10 % of the total solar production was produced at 12 PM, we assume that 10% of microgenerated solar production was produced at 12PM.
```{r}
final_gurobi = 
  final_gurobi %>%
  group_by(month, year) %>%
  mutate(total_solar = sum(solar)) %>% 
  ungroup() %>% 
  mutate(elect_inj_hourly = 
           ener_iny*solar/total_solar, 
         elect_inj_hourly_a = 
           ener_ext*solar/total_solar,
         elect_ext_hourly = 
           ener_ext*solar/total_solar)

back_of_envolpe_co2 = 
  final_gurobi
```


## Gurobi minimization

### Clean the data

We made a few minor changes now. In particular, we change the sign of exports and the name of electricity injected:
```{r}
final_gurobi <- final_gurobi %>% 
  mutate(total_exports = - total_exports) #change the negative exports to positive exports
```

```{r}
battery_size = 
  16.38/1000

final_gurobi <- final_gurobi %>%
  group_by(year, month, day) %>%
  mutate(total_elec_iny=sum(elect_inj_hourly), 
         total_batt_av =battery_size*n_firms) %>%
  ungroup() #generate the total electricity injected on a day
```

```{r}
final_gurobi %>%
  summarise(total_elec_iny = 
              mean(total_elec_iny/n_firms, na.rm = T), 
            total_batt_av = 
              mean(total_batt_av/n_firms, na.rm = T))
```


We now create the residual demand:
 
We know that:
Thermal + Hydro + Biomasss + Wind + Solar + Microgeneration + Imports = Demand + Exports (1)

Thus, we define the residual demand as: 

Demand + Exports - Hydro - Biomass - Wind - Solar - Imports (2)
 
In case the production exceeds the existing demand, we say there is no residual demand left.

CTM appears in the exports and the total production, so we need to adjust that:
```{r}
load(paste0(dir$data,
            "Gurobi/CTM_Gurobi.RData"))

final_gurobi <- final_gurobi %>% 
  mutate(r_d= demand + total_exports - total_imports - hydro - wind - solar - biomass) 

final_gurobi <- 
  final_gurobi %>% 
  arrange(year, month, hour)

final_gurobi <- merge(final_gurobi, 
                       final_data_CTM, 
                       by=c("year", "month", "day", "hour"), 
                       all.x=TRUE)

final_gurobi <- final_gurobi %>% 
  mutate(CTM = ifelse(is.na(CTM), 0, -CTM))

# 2 CTM because is sum negatively. So 2 CTM to cancel out + make it positive
final_gurobi <- final_gurobi %>% 
  mutate(residual_demand = r_d + CTM)  # create the new correct residual demand
                         
final_gurobi <- final_gurobi %>% 
  mutate(residual_demand= ifelse(
    residual_demand <0, 0, residual_demand))

final_gurobi %>% 
  summarize(mean_rd=mean(residual_demand, na.rm=TRUE), 
            sd_rd=sd(residual_demand, na.rm=TRUE), 
            min_rd=min(residual_demand, na.rm=TRUE), 
            max_rd=max(residual_demand, na.rm=TRUE))
```

We check when thermal is positive: only moment to substitute it out for:
```{r}
final_gurobi <- final_gurobi %>% 
  group_by(year, month, day) %>% 
  mutate(mean_thermal = mean(thermal)) %>% 
  ungroup()

# final_gurobi2_check <- final_gurobi2 %>% 
#   filter(mean_thermal>0)
```

We are eliminating the days which have no thermal production. Thus, when I distribute the injection of solar electricity it has to be with fewer days.
```{r}
#check <- final_gurobi_check %>% 
# filter(year==2022, month==8) 
#table(check$day)
```

```{r}
# final_gurobi <- final_gurobi %>% 
#   group_by(year, month) %>% 
#   mutate(max_day = max(day), 
#          total_residual_month = 
#            sum(residual_demand)) %>% 
#   ungroup() %>% 
#   mutate(co2_per_unit = 
#            desc_co2/total_residual_month) %>%
#   group_by(year, month, day) %>% 
#   mutate(total_residual_day = 
#            sum(residual_demand), 
#          total_residual_day_square = 
#            sum(residual_demand^2)) %>%
#   ungroup() %>% 
#   mutate(ponderator = 
#            residual_demand/total_residual_day,
#          scale_pond = 
#            total_residual_day^2/total_residual_day_square,
#          perc_thermal = 
#            ifelse(total_residual_day == 0, 
#                   0,
#                   scale_pond*ponderator*co2_per_unit))
```

### Minimization Problem

We have data from November 2018 to August 2022. We will do each year in a loop.  

Within a year, we loop within a month and hour. Our "x" variable, the variable that the model will decide where to optimally allocate, is the kWh production of microgeneration. In each round, we save such a result in the databset "A_round." Our "f(x)" variable, the variable the model will try to minimize, is the CO2 emissions associated with such a microgeneration. We will save the such a results in "A_round_solution."
```{r}
# Formally, the model will give as for each day where to optimally allocate the thermal production first and the microgeneration second. We then define a data.frame with 48 rows for that. 
A_round <- 
  data.frame("solution_mWh" = 
               c(paste0("thermal_", 0:23),paste0("micro_gen_", 0:23)))

# Formally, the model will give us the total CO2 emissions associated with the optimal solution describe before. Thus, we simply generate a data.frame with one row for that.
A_round_solution = 
      data.frame("solution_co2" = "kg")
```

First, we do 2018. We recover the number of months for such a year, which may differ year to year.
```{r}
year_round = 
  2018 

final_gurobi_round = 
  final_gurobi %>%
  filter(year == year_round)

months_in_round = 
  unique(final_gurobi_round$month)

min_month = 
  min(months_in_round)

max_month = 
  max(months_in_round)
```

Now, we do the loop. We need to define the matrices A and b for the minimization problem. For further details, please check the paper.
```{r}
for(i in min_month:max_month)
{
  
  energy_G <- final_gurobi %>% 
    filter(year==year_round, month==i)  
  
  max_day_round = energy_G$max_day[1]
  
  for(j in 1:max_day_round)
    {
    
    energy_G <- final_gurobi %>% 
      filter(year==year_round, month==i, day==j)
    
    #Now do the minimization problem:
    model <- 
      list()
    
    model$A <- 
      rbind(cbind(diag(24), diag(24)),
            c(rep(0,24), rep(1,24)), 
            c(rep(0,24), rep(1,24)))
    
    model$obj   <- c(
      energy_G$perc_thermal[1:24],rep(0, 24))
    
    model$modelsense <- 
      'min'
    
    model$rhs        <- c(energy_G$residual_demand[],
                          energy_G$total_elec_iny[1], 
                          energy_G$total_batt_av[1]) #take the whole first column
    
    model$sense      <- 
      c(rep('>=',24), '<=', '<=')                                                                              
    
    result <- 
      gurobi(model)
    
#    print('Solution:')
    
#    print(result$objval)
    
#    print(result$x)
    
    Aw = 
      data.frame("G_result"=result$x)
    
    A_solution = 
      data.frame("G_value"=result$objval)
    
    if(any(energy_G$mean_thermal > 0)) {
      
    names(Aw)[1] <- 
        paste0(names(Aw)[1], year_round,"_",i,"_", j)
      
      A_round <- cbind(A_round,
                    Aw)
      
    names(A_solution)[1] <- 
      paste0(names(A_solution)[1], year_round,"_",i,"_",j)
      
    A_round_solution <- cbind(A_round_solution,
                             A_solution)
    }
  }
}
```

We then save the solution for every year on the "final_x_solution" and "final_co2_solution" database:
```{r}
final_x_solution = 
  A_round 

final_co2_solution = 
  A_round_solution
```

The process is alike for the remaining years:
```{r}
for (year_round in 2019:2022) {
  A_round <- 
  data.frame("solution_mWh" = 
               c(paste0("thermal_", 0:23),paste0("micro_gen_", 0:23)))

A_round_solution = 
      data.frame("solution_co2" = "kg") 

final_gurobi_round = 
  final_gurobi %>%
  filter(year == year_round)

months_in_round = 
  unique(final_gurobi_round$month)

min_month = 
  min(months_in_round)

max_month = 
  max(months_in_round)

for(i in min_month:max_month)
{
  
  energy_G <- final_gurobi %>% 
    filter(year==year_round, month==i)  
  
  max_day_round = energy_G$max_day[1]
  
  for(j in 1:max_day_round)
  {
    
    energy_G <- final_gurobi %>% 
      filter(year==year_round, month==i, day==j)
    
    #Now do the minimization problem:
    model <- 
      list()
    
    model$A <- 
      rbind(cbind(diag(24), diag(24)),
            c(rep(0,24), rep(1,24)), 
            c(rep(0,24), rep(1,24)))
    
    model$obj   <- c(
      energy_G$perc_thermal[1:24],rep(0, 24))
    
    model$modelsense <- 
      'min'
    
    model$rhs        <- c(energy_G$residual_demand[],
                          energy_G$total_elec_iny[1], 
                          energy_G$total_batt_av[1]) #take the whole first column
    
    model$sense      <- 
      c(rep('>=',24), '<=', '<=')                                                                              
    
    result <- 
      gurobi(model)
    
#    print('Solution:')
    
#    print(result$objval)
    
#    print(result$x)
    
    Aw = 
      data.frame("G_result"=result$x)
    
    A_solution = 
      data.frame("G_value"=result$objval)
    
    if(any(energy_G$mean_thermal > 0)) {
      
    names(Aw)[1] <- 
        paste0(names(Aw)[1], year_round,"_",i,"_", j)
      
      A_round <- cbind(A_round,
                    Aw)
      
    names(A_solution)[1] <- 
      paste0(names(A_solution)[1], year_round,"_",i,"_",j)
      
    A_round_solution <- cbind(A_round_solution,
                             A_solution)
    }
  }
}

final_x_solution = 
  cbind(final_x_solution, 
        A_round[, 2:ncol(A_round)]) 

final_co2_solution = 
  cbind(final_co2_solution, 
        A_round_solution[, 2:ncol(A_round_solution)])
}
```

We modify the solution so it's in a long format, which is easier to manage:
```{r}
final_co2_solution_long = 
  final_co2_solution %>%
  pivot_longer(starts_with("G_value"), 
               names_to  = "date", 
               values_to = "co2_kg", 
               names_prefix = "G_value") %>%
  mutate(co2_kg = as.numeric(co2_kg)) %>%
  separate(date, c("year", "month", "day"), 
           sep="_", remove=FALSE)
```


```{r}
total_co2_emissions_gurobi = 
  final_co2_solution_long %>% 
  group_by(month, year) %>%
  summarise(total_co2_model = 
              sum(co2_kg, na.rm = T)) %>%
  ungroup()  %>%
  mutate(across(c("month", "year"), 
                as.numeric))
```

```{r}
back_of_envolpe_co2 = 
  final_gurobi %>%
  filter(residual_demand > 0 & thermal > 0)
```


We can now calculate the total CO2 emissions at baseline. We simply sum up the CO2 emissions which are a monthly level over the whole study period.
```{r}
total_co2_emissions_statuo_quo = 
  back_of_envolpe_co2 %>%
  group_by(month, year) %>%
  summarise(total_co2_emissions = 
              mean(desc_co2, na.rm = T))
```

```{r}
total_reduction_month =
  total_co2_emissions_gurobi %>%
  left_join(total_co2_emissions_statuo_quo,
            by = c("month", "year")) %>%
  mutate(reduction_co2 = 1 - total_co2_model/total_co2_emissions) %>%
  ungroup()

total_reduction_month %>%
  summarise(reduction_co2 = mean(reduction_co2))
```

### Plot

```{r}
final_x_solution_long = 
  final_x_solution %>%
    pivot_longer(starts_with("G_result"), 
               names_to  = "date", 
               values_to = "kWh", 
               names_prefix = "G_result") %>%
  mutate(kWh = as.numeric(kWh)) %>%
  separate(date, c("year", "month", "day"), 
           sep="_", remove=FALSE) 

final_x_solution_long = 
  final_x_solution_long %>% 
  filter(solution_mWh %in% paste0("micro_gen_", 0:23)) %>% 
  mutate(hour = as.numeric(substr(solution_mWh, 11, nchar(solution_mWh))))
```

```{r}
plot_final_2 <- ggplot(data = final_x_solution_long %>% 
                         filter(kWh != 0) %>%
                         group_by(hour) %>%
                         summarise(tot_days_final = n()) 
                       # %>%
                        # mutate(hour = ifelse(hour == 0, 24, hour))
                       , 
                       aes(x=hour, y=tot_days_final)) +
  geom_point(size=2) +
#  geom_vline(xintercept=8, color = "yellow", size=1) +
#  geom_vline(xintercept=16, color = "yellow", size=1) +
#  theme(text = element_text(size = 15)) +
  labs(y = "Freq. Solutions" ,x = "Hour") +
  theme(legend.key.size = unit(1, 'cm')) +
  ggtitle("Model Solution")

plot_final_2
```

```{r}
ggsave(paste0(dir$fig,"one_battery_plot.png"), 
       width = 7, height = 4.5)
```